---
icon: i-lucide-compass
---

# Introduction

> Nitro is a full-stack framework, compatible with any runtime. It extends your Vite application with a production-ready server.

Vite’s main purpose is to build frontend applications. It provides a fast dev server to transform and serve resources with HMR, but it doesn’t include a production server.

When creating an SPA, you often need to add API routes—whether to bypass CORS, call services with an API token, or implement your own backend logic. Nitro lets you create server and API routes inside the `routes/` directory of your project. You can even go further and take control of the entire server entry by creating a `server.ts` file. With its high-level and runtime-agnostic approach, Nitro allows you to use any HTTP library, such as [Elysia](https://elysiajs.com/), [h3](https://h3.dev) or [Hono](https://hono.dev).

But that’s not all: running `vite build` also builds both your backend and frontend code into an optimized `.output/` folder. This output is compatible not only with Node.js, Bun, and Deno, but also with many hosting platforms without any configuration. This means you can deploy your full-stack Vite application to Cloudflare Workers, Netlify, Vercel, and more, without changing a single line of code, while taking advantage of platform features like ESR, ISR, and SWR.

The Nitro server is highly performant. By combining code-splitting with compiled routes, it removes the need for a runtime router, leaving only minimal compiled logic. This makes it ideal for serverless hosting, since boot-up time is nearly 0ms regardless of project size and only the code required to handle the incoming request is loaded and executed.

Having a server also unlocks server-side rendering. You can render HTML with your favorite templating engine, or use component libraries such as React, Vue, or Svelte directly on the server. You can even go full universal rendering with client-side hydration. Nitro provides the foundation and a progressive approach to reach your goals.

Server data storage is often needed, and Nitro includes a runtime-agnostic key-value storage layer out of the box. It uses in-memory storage by default, but you can connect more than 20 different drivers (FS, Redis, S3, etc.), attach them to different namespaces, and swap them without changing your code.

Caching is a key part of any web server, which is why Nitro supports caching for both server routes and server functions, backed directly by the server storage (via the `cache` namespace).

When key-value storage isn’t enough, Nitro also includes a built-in SQL database. It defaults to SQLite, but you can connect to and query more than 10 databases (Postgres, MySQL, PGLite, etc.) using the same API.

Last but not least, Nitro can be used as the foundation for building your own meta-framework. Popular frameworks such as Nuxt, SolidStart and TanStack Start fully or partially leverage Nitro.

Ready to give it a try? Jump into the [quick start](/docs/quick-start).
