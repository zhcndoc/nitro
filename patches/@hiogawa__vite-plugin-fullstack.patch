diff --git a/dist/index.js b/dist/index.js
index ea1c38a7b262713dd3a8691a65bb4ba5d89ab9f7..2b8558efebc4fe5a22cf7b1b27c05473e9295de2 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -31,16 +31,25 @@ function parseAssetsVirtual(id) {
 
 //#endregion
 //#region src/plugins/utils.ts
+function escapeRegExp(string) {
+	return string.replace(/[-\\^$*+?.()|[\]{}]/g, String.raw`\$&`);
+}
 function createVirtualPlugin(name, load) {
 	name = "virtual:" + name;
 	return {
 		name: `rsc:virtual-${name}`,
-		resolveId: { handler(source, _importer, _options) {
-			return source === name ? "\0" + name : void 0;
-		} },
-		load: { handler(id, options) {
-			if (id === "\0" + name) return load.apply(this, [id, options]);
-		} }
+		resolveId: {
+			filter: { id: /* @__PURE__ */ new RegExp("^" + escapeRegExp(name) + "$") },
+			handler(source, _importer, _options) {
+				return source === name ? "\0" + name : void 0;
+			}
+		},
+		load: {
+			filter: { id: /* @__PURE__ */ new RegExp("^\\0" + escapeRegExp(name) + "$") },
+			handler(id, options) {
+				if (id === "\0" + name) return load.apply(this, [id, options]);
+			}
+		}
 	};
 }
 function normalizeRelativePath(s) {
@@ -241,72 +250,79 @@ function assetsPlugin(pluginOpts) {
 				const serverEnvironments = pluginOpts?.serverEnvironments ?? ["ssr"];
 				if (serverEnvironments.includes(name)) return { build: { emitAssets: true } };
 			},
-			transform: { async handler(code, id, _options) {
-				if (!code.includes("import.meta.vite.assets")) return;
-				const output = new MagicString(code);
-				const strippedCode = stripLiteral(code);
-				const newImports = /* @__PURE__ */ new Set();
-				for (const match of code.matchAll(/import\.meta\.vite\.assets\(([\s\S]*?)\)/dg)) {
-					const [start, end] = match.indices[0];
-					if (!strippedCode.slice(start, end).includes("import.meta.vite.assets")) continue;
-					if (this.environment.name === "client") {
-						const replacement$1 = `(${JSON.stringify(EMPTY_ASSETS)})`;
-						output.update(start, end, replacement$1);
-						continue;
+			transform: {
+				filter: { code: /import\.meta\.vite\.assets\(/ },
+				async handler(code, id, _options) {
+					const output = new MagicString(code);
+					const strippedCode = stripLiteral(code);
+					const newImports = /* @__PURE__ */ new Set();
+					for (const match of code.matchAll(/import\.meta\.vite\.assets\(([\s\S]*?)\)/dg)) {
+						const [start, end] = match.indices[0];
+						if (!strippedCode.slice(start, end).includes("import.meta.vite.assets")) continue;
+						if (this.environment.name === "client") {
+							const replacement$1 = `(${JSON.stringify(EMPTY_ASSETS)})`;
+							output.update(start, end, replacement$1);
+							continue;
+						}
+						const argCode = match[1].trim();
+						const options = {
+							import: id,
+							environment: void 0,
+							asEntry: false
+						};
+						if (argCode) {
+							const argValue = evalValue(argCode);
+							Object.assign(options, argValue);
+						}
+						const environments = options.environment ? [options.environment] : ["client", this.environment.name];
+						const importedNames = [];
+						for (const environment of environments) {
+							const importSource = toAssetsVirtual({
+								import: options.import,
+								importer: id,
+								environment,
+								entry: options.asEntry ? "1" : ""
+							});
+							const hash = hashString(importSource);
+							const importedName = `__assets_${hash}`;
+							newImports.add(`;import ${importedName} from ${JSON.stringify(importSource)};\n`);
+							importedNames.push(importedName);
+						}
+						let replacement = importedNames[0];
+						if (importedNames.length > 1) {
+							newImports.add(`;import * as __assets_runtime from "virtual:fullstack/runtime";\n`);
+							replacement = `__assets_runtime.mergeAssets(${importedNames.join(", ")})`;
+						}
+						output.update(start, end, `(${replacement})`);
 					}
-					const argCode = match[1].trim();
-					const options = {
-						import: id,
-						environment: void 0,
-						asEntry: false
-					};
-					if (argCode) {
-						const argValue = evalValue(argCode);
-						Object.assign(options, argValue);
-					}
-					const environments = options.environment ? [options.environment] : ["client", this.environment.name];
-					const importedNames = [];
-					for (const environment of environments) {
-						const importSource = toAssetsVirtual({
-							import: options.import,
-							importer: id,
-							environment,
-							entry: options.asEntry ? "1" : ""
-						});
-						const hash = hashString(importSource);
-						const importedName = `__assets_${hash}`;
-						newImports.add(`;import ${importedName} from ${JSON.stringify(importSource)};\n`);
-						importedNames.push(importedName);
+					if (output.hasChanged()) {
+						for (const newImport of newImports) output.append(newImport);
+						return {
+							code: output.toString(),
+							map: output.generateMap({ hires: "boundary" })
+						};
 					}
-					let replacement = importedNames[0];
-					if (importedNames.length > 1) {
-						newImports.add(`;import * as __assets_runtime from "virtual:fullstack/runtime";\n`);
-						replacement = `__assets_runtime.mergeAssets(${importedNames.join(", ")})`;
-					}
-					output.update(start, end, `(${replacement})`);
 				}
-				if (output.hasChanged()) {
-					for (const newImport of newImports) output.append(newImport);
-					return {
-						code: output.toString(),
-						map: output.generateMap({ hires: "boundary" })
-					};
-				}
-			} },
-			resolveId: { handler(source) {
-				if (source === "virtual:fullstack/runtime") return "\0" + source;
-				if (source.startsWith("virtual:fullstack/assets?")) return "\0" + source;
-				if (source === "virtual:fullstack/assets-manifest") {
-					assert.notEqual(this.environment.name, "client");
-					assert.equal(this.environment.mode, "build");
-					return {
-						id: source,
-						external: true
-					};
+			},
+			resolveId: {
+				filter: { id: /^virtual:fullstack\// },
+				handler(source) {
+					if (source === "virtual:fullstack/runtime") return "\0" + source;
+					if (source.startsWith("virtual:fullstack/assets?")) return "\0" + source;
+					if (source === "virtual:fullstack/assets-manifest") {
+						assert.notEqual(this.environment.name, "client");
+						assert.equal(this.environment.mode, "build");
+						return {
+							id: source,
+							external: true
+						};
+					}
 				}
-			} },
-			load: { async handler(id) {
-				if (id === "\0virtual:fullstack/runtime") return `//#region src/runtime.ts
+			},
+			load: {
+				filter: { id: /^\0virtual:fullstack\// },
+				async handler(id) {
+					if (id === "\0virtual:fullstack/runtime") return `//#region src/runtime.ts
 function mergeAssets(...args) {
 	const js = uniqBy(args.flatMap((h) => h.js), (a) => a.href);
 	const css = uniqBy(args.flatMap((h) => h.css), (a) => a.href);
@@ -333,20 +349,21 @@ function uniqBy(array, key) {
 
 //#endregion
 export { mergeAssets };`;
-				const parsed = parseAssetsVirtual(id);
-				if (!parsed) return;
-				assert.notEqual(this.environment.name, "client");
-				const resolved = await this.resolve(parsed.import, parsed.importer);
-				assert(resolved, `Failed to resolve: ${parsed.import}`);
-				const s = new MagicString("");
-				const code = await processAssetsImport(this, resolved.id, {
-					environment: parsed.environment,
-					isEntry: !!parsed.entry
-				});
-				s.append(`export default ${code};\n`);
-				if (this.environment.mode === "build") s.prepend(`import __assets_manifest from "virtual:fullstack/assets-manifest";\n`);
-				return s.toString();
-			} },
+					const parsed = parseAssetsVirtual(id);
+					if (!parsed) return;
+					assert.notEqual(this.environment.name, "client");
+					const resolved = await this.resolve(parsed.import, parsed.importer);
+					assert(resolved, `Failed to resolve: ${parsed.import}`);
+					const s = new MagicString("");
+					const code = await processAssetsImport(this, resolved.id, {
+						environment: parsed.environment,
+						isEntry: !!parsed.entry
+					});
+					s.append(`export default ${code};\n`);
+					if (this.environment.mode === "build") s.prepend(`import __assets_manifest from "virtual:fullstack/assets-manifest";\n`);
+					return s.toString();
+				}
+			},
 			renderChunk(code, chunk) {
 				if (code.includes("virtual:fullstack/assets-manifest")) {
 					const replacement = normalizeRelativePath(path.relative(path.join(chunk.fileName, ".."), BUILD_ASSETS_MANIFEST_NAME));
@@ -393,6 +410,7 @@ export { mergeAssets };`;
 			sharedDuringBuild: true,
 			resolveId: {
 				order: "pre",
+				filter: { id: /[?&]assets/ },
 				handler(source) {
 					const { query } = parseIdQuery(source);
 					const value = query["assets"];
@@ -401,41 +419,44 @@ export { mergeAssets };`;
 					}
 				}
 			},
-			load: { async handler(id) {
-				if (id === "\0virtual:fullstack/empty-assets") return `export default ${JSON.stringify(EMPTY_ASSETS)}`;
-				const { filename, query } = parseIdQuery(id);
-				const value = query["assets"];
-				if (typeof value !== "undefined") {
-					const s = new MagicString("");
-					const codes = [];
-					if (value) {
-						const code = await processAssetsImport(this, filename, {
-							environment: value,
-							isEntry: value === "client"
-						});
-						codes.push(code);
-					} else {
-						const code1 = await processAssetsImport(this, filename, {
-							environment: "client",
-							isEntry: false
-						});
-						const code2 = await processAssetsImport(this, filename, {
-							environment: this.environment.name,
-							isEntry: false
-						});
-						codes.push(code1, code2);
-					}
-					s.append(`
+			load: {
+				filter: { id: [/^\0virtual:fullstack\/empty-assets$/, /[?&]assets/] },
+				async handler(id) {
+					if (id === "\0virtual:fullstack/empty-assets") return `export default ${JSON.stringify(EMPTY_ASSETS)}`;
+					const { filename, query } = parseIdQuery(id);
+					const value = query["assets"];
+					if (typeof value !== "undefined") {
+						const s = new MagicString("");
+						const codes = [];
+						if (value) {
+							const code = await processAssetsImport(this, filename, {
+								environment: value,
+								isEntry: value === "client"
+							});
+							codes.push(code);
+						} else {
+							const code1 = await processAssetsImport(this, filename, {
+								environment: "client",
+								isEntry: false
+							});
+							const code2 = await processAssetsImport(this, filename, {
+								environment: this.environment.name,
+								isEntry: false
+							});
+							codes.push(code1, code2);
+						}
+						s.append(`
 import * as __assets_runtime from "virtual:fullstack/runtime";\n
 export default __assets_runtime.mergeAssets(${codes.join(", ")});
 `);
-					if (this.environment.mode === "build") s.prepend(`import __assets_manifest from "virtual:fullstack/assets-manifest";\n`);
-					return {
-						code: s.toString(),
-						moduleSideEffects: false
-					};
+						if (this.environment.mode === "build") s.prepend(`import __assets_manifest from "virtual:fullstack/assets-manifest";\n`);
+						return {
+							code: s.toString(),
+							moduleSideEffects: false
+						};
+					}
 				}
-			} },
+			},
 			hotUpdate(ctx) {
 				if (this.environment.name === "rsc") {
 					const mods = collectModuleDependents(ctx.modules);
@@ -556,11 +577,13 @@ function patchViteClientPlugin() {
 	}
 	return {
 		name: "fullstack:patch-vite-client",
-		transform: { handler(code, id) {
-			if (id === viteClientPath) {
-				if (code.includes("linkSheetsMap")) return;
-				const s = new MagicString(code);
-				s.prependLeft(code.indexOf("const sheetsMap"), `\
+		transform: {
+			filter: { id: /* @__PURE__ */ new RegExp("^" + escapeRegExp(viteClientPath) + "$") },
+			handler(code, id) {
+				if (id === viteClientPath) {
+					if (code.includes("linkSheetsMap")) return;
+					const s = new MagicString(code);
+					s.prependLeft(code.indexOf("const sheetsMap"), `\
 const linkSheetsMap = new Map();
 document
   .querySelectorAll('link[rel="stylesheet"][data-vite-dev-id]')
@@ -568,8 +591,8 @@ document
     linkSheetsMap.set(el.getAttribute('data-vite-dev-id'), el)
   });
 `);
-				s.appendLeft(endIndexOf(code, `function updateStyle(id, content) {`), `if (linkSheetsMap.has(id)) { return }`);
-				s.appendLeft(endIndexOf(code, `function removeStyle(id) {`), `
+					s.appendLeft(endIndexOf(code, `function updateStyle(id, content) {`), `if (linkSheetsMap.has(id)) { return }`);
+					s.appendLeft(endIndexOf(code, `function removeStyle(id) {`), `
 const link = linkSheetsMap.get(id);
 if (link) {
   document
@@ -584,9 +607,10 @@ if (link) {
   linkSheetsMap.delete(id)
 }
 `);
-				return s.toString();
+					return s.toString();
+				}
 			}
-		} }
+		}
 	};
 }
 function patchVueScopeCssHmr() {
